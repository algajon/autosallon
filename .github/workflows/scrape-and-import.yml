name: Scrape & Import (Hostinger via SSH tunnel)

on:
  workflow_dispatch:
  schedule:
    - cron: "17 * * * *"

permissions:
  contents: read

concurrency:
  group: scrape-import
  cancel-in-progress: false

jobs:
  run:
    runs-on: ubuntu-latest
    timeout-minutes: 45

    env:
      CSV_DIR: ${{ secrets.CSV_DIR != '' && secrets.CSV_DIR || 'scripts' }}
      CSV_NAME: cars.csv
      KRW_EUR: ${{ secrets.KRW_EUR != '' && secrets.KRW_EUR || '0.000615' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install minimal deps (SSH client only)
        run: |
          sudo apt-get update
          sudo apt-get install -y openssh-client

      - name: Prepare SSH key (key-only; no password)
        env:
          SSH_KEY: ${{ secrets.HOSTINGER_SSH_KEY }}
        run: |
          set -e
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          echo "$SSH_KEY" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          if ! ssh-keygen -y -f ~/.ssh/id_ed25519 >/dev/null 2>&1; then
            echo "HOSTINGER_SSH_KEY is invalid or passphrase-protected."
            exit 1
          fi
          cat > ~/.ssh/config <<'CFG'
          Host *
            ServerAliveInterval 30
            ServerAliveCountMax 3
            IdentitiesOnly yes
            PreferredAuthentications publickey
            PasswordAuthentication no
            StrictHostKeyChecking no
          CFG

      - name: Sanity SSH auth
        env:
          SSH_HOST: ${{ secrets.HOSTINGER_SSH_HOST }}
          SSH_PORT: ${{ secrets.HOSTINGER_SSH_PORT }}
          SSH_USER: ${{ secrets.HOSTINGER_SSH_USER }}
        run: |
          ssh -o IdentitiesOnly=yes -i ~/.ssh/id_ed25519 -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "echo SSH OK"

      # ---------- SCRAPER ----------
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Clean stale Chrome (best-effort)
        run: |
          pkill -f chrome || true
          pkill -f chromedriver || true

      - name: Install Python requirements
        run: |
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: Run scraper
        env:
          KRW_EUR: ${{ env.KRW_EUR }}
        run: |
          set -e
          mkdir -p "$CSV_DIR"
          python scripts/github.py
          test -s "${CSV_DIR}/${CSV_NAME}" || { echo "CSV not found at ${CSV_DIR}/${CSV_NAME}"; exit 1; }
          ls -lh "${CSV_DIR}/${CSV_NAME}"

      # ---------- PUSH CSV + IMPORT (batched UPSERTs; no LOAD DATA) ----------
      - name: Create importer script (local)
        run: |
          cat > importer.py <<'PY'
          #!/usr/bin/env python3
          import os, sys, csv, ssl
          import pymysql

          host     = os.environ['DB_HOST']
          user     = os.environ['DB_USER']
          password = os.environ['DB_PASS']
          database = os.environ['DB_NAME']
          csv_path = os.environ['CSV_PATH']

          def to_int(x):
            if x is None: return None
            s = str(x).strip()
            if not s or s.lower() in {"null","none","nan"}: return None
            s = s.replace(",","")
            try: return int(float(s))
            except: return None

          def connect():
            # Try plain first; if server enforces TLS, fall back with TLS (no verify)
            try:
              return pymysql.connect(host=host, user=user, password=password, database=database,
                                     port=3306, charset="utf8mb4", connect_timeout=15)
            except Exception:
              ctx = ssl.create_default_context()
              ctx.check_hostname = False
              ctx.verify_mode = ssl.CERT_NONE
              return pymysql.connect(host=host, user=user, password=password, database=database,
                                     port=3306, charset="utf8mb4", connect_timeout=15, ssl={"ssl": ctx})

          conn = connect()
          cur = conn.cursor()
          cur.execute("SELECT @@version, CURRENT_USER(), USER()")
          print("server,cur_user,login_user:", cur.fetchone(), flush=True)

          cur.execute("""
          CREATE TABLE IF NOT EXISTS vehicles (
            prodhuesi        VARCHAR(80),
            modeli           VARCHAR(120),
            varianti         VARCHAR(160),
            viti             VARCHAR(8),
            cmimi_eur        INT,
            kilometrazhi_km  INT,
            karburanti       VARCHAR(40),
            ngjyra           VARCHAR(40),
            transmisioni     VARCHAR(40),
            uleset           VARCHAR(8),
            vin              VARCHAR(40),
            engine_cc        INT,
            images           TEXT,
            listing_url      VARCHAR(512),
            opsionet         MEDIUMTEXT,
            raporti_url      TEXT
          ) DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
          """)
          cur.execute("""
          SELECT COUNT(1) FROM information_schema.statistics
          WHERE table_schema = DATABASE() AND table_name='vehicles' AND index_name='uniq_listing_url'
          """)
          if cur.fetchone()[0] == 0:
            cur.execute("ALTER TABLE vehicles ADD UNIQUE KEY uniq_listing_url (listing_url(255))")

          cols = ("prodhuesi","modeli","varianti","viti","cmimi_eur","kilometrazhi_km","karburanti","ngjyra",
                  "transmisioni","uleset","vin","engine_cc","images","listing_url","opsionet","raporti_url")
          placeholders = ",".join(["%s"]*len(cols))
          sql = f"""
          INSERT INTO vehicles ({",".join(cols)}) VALUES ({placeholders})
          ON DUPLICATE KEY UPDATE
            prodhuesi=VALUES(prodhuesi),
            modeli=VALUES(modeli),
            varianti=VALUES(varianti),
            viti=VALUES(viti),
            cmimi_eur=VALUES(cmimi_eur),
            kilometrazhi_km=VALUES(kilometrazhi_km),
            karburanti=VALUES(karburanti),
            ngjyra=VALUES(ngjyra),
            transmisioni=VALUES(transmisioni),
            uleset=VALUES(uleset),
            vin=VALUES(vin),
            engine_cc=VALUES(engine_cc),
            images=VALUES(images),
            opsionet=VALUES(opsionet),
            raporti_url=VALUES(raporti_url)
          """

          total = 0
          batch, BATCH_SIZE = [], 500

          with open(csv_path, "r", encoding="utf-8", newline="") as f:
            reader = csv.DictReader(f)
            for r in reader:
              batch.append((
                r.get("prodhuesi"),
                r.get("modeli"),
                r.get("varianti"),
                r.get("viti"),
                to_int(r.get("cmimi_eur")),
                to_int(r.get("kilometrazhi_km")),
                r.get("karburanti"),
                r.get("ngjyra"),
                r.get("transmisioni"),
                r.get("uleset"),
                r.get("vin"),
                to_int(r.get("engine_cc")),
                r.get("images"),
                r.get("listing_url"),
                r.get("opsionet"),
                r.get("raporti_url"),
              ))
              if len(batch) >= BATCH_SIZE:
                cur.executemany(sql, batch); conn.commit(); total += len(batch); batch.clear()
          if batch:
            cur.executemany(sql, batch); conn.commit(); total += len(batch)

          print(f"upserted_rows={total}", flush=True)
          cur.close(); conn.close()
          PY

      - name: Push CSV + importer to SSH host
        env:
          SSH_HOST: ${{ secrets.HOSTINGER_SSH_HOST }}
          SSH_PORT: ${{ secrets.HOSTINGER_SSH_PORT }}
          SSH_USER: ${{ secrets.HOSTINGER_SSH_USER }}
          CSV_DIR: ${{ env.CSV_DIR }}
          CSV_NAME: ${{ env.CSV_NAME }}
        run: |
          set -e
          LOCAL_CSV="$GITHUB_WORKSPACE/${CSV_DIR}/${CSV_NAME}"
          test -s "$LOCAL_CSV" || { echo "CSV not found at $LOCAL_CSV"; exit 1; }

          REMOTE_DIR="/tmp/encar_${GITHUB_RUN_ID}_${GITHUB_RUN_ATTEMPT}"
          REMOTE_CSV="${REMOTE_DIR}/cars.csv"
          REMOTE_SCRIPT="${REMOTE_DIR}/importer.py"

          ssh -i ~/.ssh/id_ed25519 -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "mkdir -p '$REMOTE_DIR'"
          scp -P "$SSH_PORT" -i ~/.ssh/id_ed25519 "$LOCAL_CSV" "$SSH_USER@$SSH_HOST:$REMOTE_CSV"
          scp -P "$SSH_PORT" -i ~/.ssh/id_ed25519 importer.py "$SSH_USER@$SSH_HOST:$REMOTE_SCRIPT"

          echo "REMOTE_DIR=$REMOTE_DIR"         >> $GITHUB_ENV
          echo "REMOTE_CSV=$REMOTE_CSV"         >> $GITHUB_ENV
          echo "REMOTE_SCRIPT=$REMOTE_SCRIPT"   >> $GITHUB_ENV

      - name: Import on SSH host (Python; no LOAD DATA)
        env:
          SSH_HOST: ${{ secrets.HOSTINGER_SSH_HOST }}
          SSH_PORT: ${{ secrets.HOSTINGER_SSH_PORT }}
          SSH_USER: ${{ secrets.HOSTINGER_SSH_USER }}
          DB_NAME:  ${{ secrets.DB_DATABASE }}
          DB_USER:  ${{ secrets.DB_USERNAME }}
          DB_PASS:  ${{ secrets.DB_PASSWORD }}
          REMOTE_CSV: ${{ env.REMOTE_CSV }}
          REMOTE_SCRIPT: ${{ env.REMOTE_SCRIPT }}
        run: |
          set -e
          # Ensure a usable Python and PyMySQL on the SSH host (user-space only; no sudo required)
          ssh -i ~/.ssh/id_ed25519 -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash -s <<'REMOTE'
          set -e
          PY="$(command -v python3 || command -v python || true)"
          if [ -z "$PY" ]; then
            echo "No python found on SSH host. Attempting user-space bootstrap..."
            # Quick user-space bootstrap via pyenv-ish fallback (skipped here to keep it lean)
            echo "Please install python3 on the SSH host." >&2
            exit 1
          fi
          "$PY" - <<'PYCHK'
           import sys, subprocess
           try:
             import pymysql  # noqa: F401
             print("pymysql: OK")
           except Exception:
             print("pymysql: installing...", flush=True)
             try:
               import ensurepip, site  # noqa: F401
               ensurepip.bootstrap()
             except Exception:
               pass
             subprocess.check_call([sys.executable, "-m", "pip", "install", "--user", "pymysql"])
             import pymysql  # re-check
             print("pymysql: installed")
           PYCHK
                     REMOTE

                     # Run importer with env (password masked by Actions)
                     ssh -i ~/.ssh/id_ed25519 -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" \
                       DB_HOST="srv1802.hstgr.io" \
                       DB_NAME="$DB_NAME" \
                       DB_USER="$DB_USER" \
                       DB_PASS="$DB_PASS" \
                       CSV_PATH="$REMOTE_CSV" \
                       "python3 '$REMOTE_SCRIPT' || python '$REMOTE_SCRIPT'"

                 - name: Cleanup remote temp files (best-effort)
                   if: always()
                   env:
                     SSH_HOST: ${{ secrets.HOSTINGER_SSH_HOST }}
                     SSH_PORT: ${{ secrets.HOSTINGER_SSH_PORT }}
                     SSH_USER: ${{ secrets.HOSTINGER_SSH_USER }}
                     REMOTE_DIR: ${{ env.REMOTE_DIR }}
                   run: |
                     ssh -i ~/.ssh/id_ed25519 -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "rm -rf '$REMOTE_DIR' || true"

