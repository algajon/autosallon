      - name: Start SSH tunnel to Hostinger (MySQL)
        env:
          SSH_HOST: ${{ secrets.HOSTINGER_SSH_HOST }}
          SSH_PORT: ${{ secrets.HOSTINGER_SSH_PORT }}
          SSH_USER: ${{ secrets.HOSTINGER_SSH_USER }}
          DB_PORT:  ${{ env.DB_PORT }}
          REMOTE_DB_HOST: ${{ env.REMOTE_DB_HOST }}
        run: |
          set -euo pipefail
          if [ -z "${REMOTE_DB_HOST}" ]; then
            echo "REMOTE_DB_HOST secret is empty. Set it to your MySQL host (often NOT the SSH host)." >&2
            exit 1
          fi
          ssh -f -N \
            -o ExitOnForwardFailure=yes \
            -o IdentitiesOnly=yes -i ~/.ssh/id_ed25519 \
            -L ${DB_PORT}:${REMOTE_DB_HOST}:3306 \
            -p "${SSH_PORT}" "${SSH_USER}@${SSH_HOST}"

          for i in {1..20}; do
            if ss -lnt | grep -q ":${DB_PORT}"; then
              echo "Tunnel up on port ${DB_PORT} â†’ ${REMOTE_DB_HOST}:3306"
              exit 0
            fi
            sleep 0.5
          done
          echo "Tunnel did not open" >&2
          exit 1

      # âœ… Wait for MySQL over the tunnel (no password warning)
      - name: Wait for MySQL over tunnel
        env:
          DB_USER: ${{ secrets.DB_USERNAME }}
          DB_PASS: ${{ secrets.DB_PASSWORD }}
          DB_HOST: ${{ env.DB_HOST }}
          DB_PORT: ${{ env.DB_PORT }}
        run: |
          set -euo pipefail
          for i in {1..30}; do
            if MYSQL_PWD="$DB_PASS" mysqladmin \
                 --protocol=TCP -h "$DB_HOST" -P "$DB_PORT" -u "$DB_USER" \
                 ping --silent; then
              echo "MySQL reachable over tunnel"
              exit 0
            fi
            echo "Waiting for MySQL ($i/30)â€¦"
            sleep 2
          done
          echo "MySQL not reachable" >&2
          exit 1

      # âœ… NOW check MySQL auth (AFTER tunnel)
      - name: Check MySQL auth over tunnel
        env:
          DB_NAME: ${{ secrets.DB_DATABASE }}
          DB_USER: ${{ secrets.DB_USERNAME }}
          DB_PASS: ${{ secrets.DB_PASSWORD }}
          DB_HOST: ${{ env.DB_HOST }}
          DB_PORT: ${{ env.DB_PORT }}
        run: |
          set -euo pipefail
          export MYSQL_PWD="${DB_PASS}"
          echo "Trying to connect to ${DB_HOST}:${DB_PORT} as ${DB_USER} (DB: ${DB_NAME})"
          mysql --protocol=TCP -h "${DB_HOST}" -P "${DB_PORT}" -u "${DB_USER}" -e "SELECT CURRENT_USER() AS who, VERSION() AS ver;"
          mysql --protocol=TCP -h "${DB_HOST}" -P "${DB_PORT}" -u "${DB_USER}" -e "SHOW DATABASES;"
          mysql --protocol=TCP -h "${DB_HOST}" -P "${DB_PORT}" -u "${DB_USER}" -e "SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME='${DB_NAME}';"

      # --- Run your scraper (writes CSV to $CSV_DIR/$CSV_NAME) ---
      - name: Install Python requirements
        run: |
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: Prepare unique Chrome profile dir
        run: |
          echo "CHROME_USER_DATA_DIR=$RUNNER_TEMP/chrome-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}" >> $GITHUB_ENV
          mkdir -p "$RUNNER_TEMP/chrome-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}"

      - name: Clean stale Chrome (best-effort)
        run: |
          pkill -f chrome || true
          pkill -f chromedriver || true

      - name: Run scraper
        env:
          KRW_EUR: ${{ secrets.KRW_EUR }}
          CHROME_USER_DATA_DIR: ${{ runner.temp }}/chrome-${{ github.run_id }}-${{ github.job }}-${{ github.run_attempt }}-${{ strategy.job-index }}
        run: |
          set -e
          mkdir -p "$CSV_DIR"
          python scripts/github.py
          test -s "${CSV_DIR}/${CSV_NAME}" || (echo "CSV not found at ${CSV_DIR}/${CSV_NAME}" >&2; exit 1)
          ls -lh "${CSV_DIR}/${CSV_NAME}"

      # ðŸ“¦ Upload CSV artifact so you can view it even if import fails
      - name: Upload CSV artifact
        uses: actions/upload-artifact@v4
        with:
          name: scraped-cars
          path: ${{ env.CSV_DIR }}/${{ env.CSV_NAME }}
          if-no-files-found: error
          retention-days: 7

      # --- Import CSV into MySQL over the tunnel ---
      - name: Import CSV into MySQL (UPSERT)
        env:
          DB_NAME: ${{ secrets.DB_DATABASE }}
          DB_USER: ${{ secrets.DB_USERNAME }}
          DB_PASS: ${{ secrets.DB_PASSWORD }}
          DB_HOST: ${{ env.DB_HOST }}
          DB_PORT: ${{ env.DB_PORT }}
        run: |
          set -euo pipefail
          CSV_PATH="$(pwd)/${CSV_DIR}/${CSV_NAME}"
          export MYSQL_PWD="${DB_PASS}"

          MYSQL_BASE="mysql --protocol=TCP --local-infile=1 -h ${DB_HOST} -P ${DB_PORT} -u ${DB_USER} ${DB_NAME}"

          echo "MySQL ping/version:"
          ${MYSQL_BASE} -e "SELECT VERSION();"

          ${MYSQL_BASE} <<'SQL'
          DROP TABLE IF EXISTS stg_encar;
          CREATE TABLE stg_encar (
            prodhuesi        VARCHAR(80),
            modeli           VARCHAR(120),
            varianti         VARCHAR(160),
            viti             VARCHAR(8),
            cmimi_eur        INT,
            kilometrazhi_km  INT,
            karburanti       VARCHAR(40),
            ngjyra           VARCHAR(40),
            transmisioni     VARCHAR(40),
            uleset           VARCHAR(8),
            vin              VARCHAR(40),
            engine_cc        INT,
            images           TEXT,
            listing_url      VARCHAR(512),
            opsionet         MEDIUMTEXT,
            raporti_url      TEXT
          ) DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
          SQL

          ${MYSQL_BASE} --execute="SET SESSION local_infile=1;"
          ${MYSQL_BASE} --execute="
            LOAD DATA LOCAL INFILE '${CSV_PATH}'
            INTO TABLE stg_encar
            CHARACTER SET utf8mb4
            FIELDS TERMINATED BY ','  ENCLOSED BY '\"'
            LINES TERMINATED BY '\n'
            IGNORE 1 LINES
            (prodhuesi, modeli, varianti, viti, cmimi_eur, kilometrazhi_km, karburanti, ngjyra,
             transmisioni, uleset, vin, engine_cc, images, listing_url, opsionet, raporti_url);
          "

          ${MYSQL_BASE} <<'SQL'
          CREATE TABLE IF NOT EXISTS vehicles LIKE stg_encar;
          ALTER TABLE vehicles
            ADD UNIQUE KEY uniq_listing_url (listing_url(255));
          INSERT INTO vehicles (
            prodhuesi, modeli, varianti, viti, cmimi_eur, kilometrazhi_km, karburanti, ngjyra,
            transmisioni, uleset, vin, engine_cc, images, listing_url, opsionet, raporti_url
          )
          SELECT
            prodhuesi, modeli, varianti, viti, cmimi_eur, kilometrazhi_km, karburanti, ngjyra,
            transmisioni, uleset, vin, engine_cc, images, listing_url, opsionet, raporti_url
          FROM stg_encar
          ON DUPLICATE KEY UPDATE
            prodhuesi=VALUES(prodhuesi),
            modeli=VALUES(modeli),
            varianti=VALUES(varianti),
            viti=VALUES(viti),
            cmimi_eur=VALUES(cmimi_eur),
            kilometrazhi_km=VALUES(kilometrazhi_km),
            karburanti=VALUES(karburanti),
            ngjyra=VALUES(ngjyra),
            transmisioni=VALUES(transmisioni),
            uleset=VALUES(uleset),
            vin=VALUES(vin),
            engine_cc=VALUES(engine_cc),
            images=VALUES(images),
            opsionet=VALUES(opsionet),
            raporti_url=VALUES(raporti_url);
          SQL

      # ðŸ§¯ If import fails, dump grants & user host for quick diagnosis
      - name: On failure: Show user/host grants
        if: failure()
        env:
          DB_NAME: ${{ secrets.DB_DATABASE }}
          DB_USER: ${{ secrets.DB_USERNAME }}
          DB_PASS: ${{ secrets.DB_PASSWORD }}
          DB_HOST: ${{ env.DB_HOST }}
          DB_PORT: ${{ env.DB_PORT }}
        run: |
          set -euo pipefail
          export MYSQL_PWD="${DB_PASS}"
          echo "Who am I?"
          mysql --protocol=TCP -h "${DB_HOST}" -P "${DB_PORT}" -u "${DB_USER}" -e "SELECT CURRENT_USER() AS who, USER() AS user;"
          echo "Show matching accounts for this username:"
          mysql --protocol=TCP -h "${DB_HOST}" -P "${DB_PORT}" -u "${DB_USER}" -e "SELECT user, host FROM mysql.user WHERE user='${DB_USER}'\G" || true
