name: Scrape & Import (Hostinger via SSH tunnel)

on:
  workflow_dispatch:
  schedule:
    - cron: "17 * * * *"

permissions:
  contents: read

concurrency:
  group: scrape-import
  cancel-in-progress: false

jobs:
  run:
    runs-on: ubuntu-latest
    timeout-minutes: 45

    env:
      # Local tunnel target
      TUNNEL_HOST: 127.0.0.1
      TUNNEL_PORT: 3307

      # Scraper outputs
      CSV_NAME: cars.csv
      # Prefer repo/environment VARs for non-secret values; fall back to literal defaults
      CSV_DIR: ${{ vars.CSV_DIR != '' && vars.CSV_DIR || 'scripts' }}
      KRW_EUR: ${{ vars.KRW_EUR != '' && vars.KRW_EUR || '0.000615' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install system deps (MySQL client, SSH)
        run: |
          sudo apt-get update
          sudo apt-get install -y mysql-client openssh-client

      - name: Prepare SSH key (key-only; no password)
        env:
          SSH_KEY: ${{ secrets.HOSTINGER_SSH_KEY }}
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          printf '%s\n' "$SSH_KEY" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          if ! ssh-keygen -y -f ~/.ssh/id_ed25519 >/dev/null 2>&1; then
            echo "HOSTINGER_SSH_KEY is invalid or passphrase-protected." >&2
            exit 1
          fi
          # Safer than StrictHostKeyChecking=no; learns unknown hosts once
          cat > ~/.ssh/config <<'CFG'
          Host *
            ServerAliveInterval 30
            ServerAliveCountMax 3
            IdentitiesOnly yes
            PreferredAuthentications publickey
            PasswordAuthentication no
            StrictHostKeyChecking accept-new
          CFG
          chmod 600 ~/.ssh/config

      - name: Sanity SSH auth
        env:
          SSH_HOST: ${{ secrets.HOSTINGER_SSH_HOST }}
          SSH_PORT: ${{ secrets.HOSTINGER_SSH_PORT }}
          SSH_USER: ${{ secrets.HOSTINGER_SSH_USER }}
        run: |
          set -euo pipefail
          ssh -o LogLevel=ERROR -o IdentitiesOnly=yes -i ~/.ssh/id_ed25519 \
            -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "echo SSH_OK"

      - name: Start SSH tunnel (runner:3307 → bastion → Hostinger MySQL)
        env:
          SSH_HOST: ${{ secrets.HOSTINGER_SSH_HOST }}
          SSH_PORT: ${{ secrets.HOSTINGER_SSH_PORT }}
          SSH_USER: ${{ secrets.HOSTINGER_SSH_USER }}
          REMOTE_DB_HOST: ${{ secrets.REMOTE_DB_HOST }}
        run: |
          set -euo pipefail
          # Backgrounded local TCP forward: 127.0.0.1:3307 -> REMOTE_DB_HOST:3306 via SSH_HOST
          ssh -f -N -4 \
            -o ExitOnForwardFailure=yes \
            -o IdentitiesOnly=yes -i ~/.ssh/id_ed25519 \
            -L ${TUNNEL_PORT}:${REMOTE_DB_HOST}:3306 \
            -p "${SSH_PORT}" "${SSH_USER}@${SSH_HOST}"

          # Wait for the listener to come up
          for i in {1..20}; do
            if ss -lnt | grep -q ":${TUNNEL_PORT}"; then
              echo "Tunnel up: ${TUNNEL_HOST}:${TUNNEL_PORT} -> ${REMOTE_DB_HOST}:3306 via ${SSH_HOST}"
              exit 0
            fi
            sleep 0.5
          done
          echo "Tunnel did not open" >&2
          exit 1

      # === Optional: Chrome/Chromedriver for Selenium-like scrapers ===
      - name: Setup Chrome (optional)
        id: chrome
        uses: browser-actions/setup-chrome@v1
        with: 
          chrome-version: stable

      - name: Expose CHROME_BIN env (optional)
        run: echo "CHROME_BIN=${{ steps.chrome.outputs.chrome-path }}" >> $GITHUB_ENV

      # === Your scraper (writes CSV to $CSV_DIR/$CSV_NAME) ===
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Prepare unique Chrome profile dir
        run: |
          echo "CHROME_USER_DATA_DIR=$RUNNER_TEMP/chrome-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}" >> $GITHUB_ENV
          mkdir -p "$RUNNER_TEMP/chrome-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}"

      - name: Clean stale Chrome (best-effort)
        run: |
          pkill -f chrome || true
          pkill -f chromedriver || true

      - name: Install Python requirements
        run: |
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: Run scraper
        env:
          KRW_EUR: ${{ env.KRW_EUR }}
          CSV_DIR: ${{ env.CSV_DIR }}
          CSV_NAME: ${{ env.CSV_NAME }}
        run: |
          set -euo pipefail
          mkdir -p "$CSV_DIR"
          python scripts/github.py
          test -s "${CSV_DIR}/${CSV_NAME}" || { echo "CSV not found at ${CSV_DIR}/${CSV_NAME}" >&2; exit 1; }
          ls -lh "${CSV_DIR}/${CSV_NAME}"

      # === MySQL import (explicit -p so we 100% send a password) ===
      - name: Import CSV into MySQL (UPSERT, no LOCAL INFILE)
        env:
          DB_DATABASE: ${{ secrets.DB_DATABASE }}
          DB_USERNAME: ${{ secrets.DB_USERNAME }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        run: |
          set -euo pipefail
          [[ -n "${DB_DATABASE:-}" ]] || { echo "DB_DATABASE missing"; exit 1; }
          [[ -n "${DB_USERNAME:-}" ]] || { echo "DB_USERNAME missing"; exit 1; }
          [[ -n "${DB_PASSWORD:-}" ]] || { echo "DB_PASSWORD missing"; exit 1; }

          HOST="${TUNNEL_HOST}"
          PORT="${TUNNEL_PORT}"
          CSV_PATH="$(pwd)/${CSV_DIR}/${CSV_NAME}"

          echo "MySQL ping/version:"
          mysql --protocol=TCP --ssl-mode=REQUIRED \
            -h "$HOST" -P "$PORT" -u "$DB_USERNAME" -p"$DB_PASSWORD" \
            -e "SELECT VERSION() AS version, CURRENT_USER() AS user;"

          # Ensure target table and unique index (same schema as before)
          mysql --protocol=TCP --ssl-mode=REQUIRED \
            -h "$HOST" -P "$PORT" -u "$DB_USERNAME" -p"$DB_PASSWORD" "$DB_DATABASE" <<'SQL'
          CREATE TABLE IF NOT EXISTS vehicles (
            prodhuesi        VARCHAR(80),
            modeli           VARCHAR(120),
            varianti         VARCHAR(160),
            viti             VARCHAR(8),
            cmimi_eur        INT,
            kilometrazhi_km  INT,
            karburanti       VARCHAR(40),
            ngjyra           VARCHAR(40),
            transmisioni     VARCHAR(40),
            uleset           VARCHAR(8),
            vin              VARCHAR(40),
            engine_cc        INT,
            images           TEXT,
            listing_url      VARCHAR(512),
            opsionet         MEDIUMTEXT,
            raporti_url      TEXT,
            UNIQUE KEY uniq_listing_url (listing_url(255))
          ) DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
          SQL

          python - <<'PY'
          import csv, os, sys
          import pymysql

          host = os.environ["TUNNEL_HOST"]
          port = int(os.environ["TUNNEL_PORT"])
          user = os.environ["DB_USERNAME"]
          password = os.environ["DB_PASSWORD"]
          db = os.environ["DB_DATABASE"]
          csv_path = os.path.abspath(os.path.join(os.getcwd(), os.environ["CSV_DIR"], os.environ["CSV_NAME"]))

          def to_int(s):
            s = (s or "").strip()
            # Remove thousands separators or spaces if present
            s = s.replace(",", "").replace(" ", "")
            return int(s) if s and s.lower() not in ("null", "none") else None

          conn = pymysql.connect(
              host=host, port=port, user=user, password=password, database=db,
              charset="utf8mb4", autocommit=False, cursorclass=pymysql.cursors.Cursor
          )
          cur = conn.cursor()

          sql = """
          INSERT INTO vehicles (
            prodhuesi, modeli, varianti, viti, cmimi_eur, kilometrazhi_km, karburanti, ngjyra,
            transmisioni, uleset, vin, engine_cc, images, listing_url, opsionet, raporti_url
          ) VALUES (
            %s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s
          )
          ON DUPLICATE KEY UPDATE
            prodhuesi=VALUES(prodhuesi),
            modeli=VALUES(modeli),
            varianti=VALUES(varianti),
            viti=VALUES(viti),
            cmimi_eur=VALUES(cmimi_eur),
            kilometrazhi_km=VALUES(kilometrazhi_km),
            karburanti=VALUES(karburanti),
            ngjyra=VALUES(ngjyra),
            transmisioni=VALUES(transmisioni),
            uleset=VALUES(uleset),
            vin=VALUES(vin),
            engine_cc=VALUES(engine_cc),
            images=VALUES(images),
            opsionet=VALUES(opsionet),
            raporti_url=VALUES(raporti_url)
          """

          batch, batch_size, total = [], 500, 0
          with open(csv_path, "r", encoding="utf-8", newline="") as f:
            reader = csv.DictReader(f)
            for row in reader:
              vals = (
                row.get("prodhuesi"),
                row.get("modeli"),
                row.get("varianti"),
                row.get("viti"),
                to_int(row.get("cmimi_eur")),
                to_int(row.get("kilometrazhi_km")),
                row.get("karburanti"),
                row.get("ngjyra"),
                row.get("transmisioni"),
                row.get("uleset"),
                row.get("vin"),
                to_int(row.get("engine_cc")),
                row.get("images"),
                row.get("listing_url"),
                row.get("opsionet"),
                row.get("raporti_url"),
              )
              batch.append(vals)
              if len(batch) >= batch_size:
                cur.executemany(sql, batch)
                conn.commit()
                total += len(batch)
                batch.clear()
          if batch:
            cur.executemany(sql, batch)
            conn.commit()
            total += len(batch)

          cur.close()
          conn.close()
          print(f"Upserted {total} rows from {csv_path}")
          PY
